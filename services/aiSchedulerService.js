const mongoose = require('mongoose');
const moment = require('moment-timezone');

// ===================== MODELS =====================
const AiScheduledPost = require('../models/AiScheduledPost');
const AiTopic = require('../models/AiTopic');
const AiLog = require('../models/AiLog');
const Page = require('../models/Page');

// ===================== AI PROVIDERS =====================
const {
  CloudflareText,
  GrokText,
  OpenAIText,
  CohereText,
  ClaudeText,
  AIHordeText,
  AI21Text,
  // DeepseekText, // Uncomment after setting process.env.DEEPSEEK_API_KEY
} = require('../services/textProviders');

const {
  CloudflareImage,
  StabilityImage,
  LeonardoImage,
  DALLEImage,
} = require('../services/imageProviders');

// Unified arrays
const TextProviders = [
  CloudflareText,
  GrokText,
  OpenAIText,
  CohereText,
  ClaudeText,
  AIHordeText,
  AI21Text,
  // DeepseekText, // Uncomment to enable
];

const ImageProviders = [
  CloudflareImage,
  StabilityImage,
  LeonardoImage,
  DALLEImage,
];

// ===================== PROVIDER STATE =====================
const providerState = {};
function initProviderState() {
  TextProviders.concat(ImageProviders).forEach(p => {
    providerState[p.name] = {
      name: p.name,
      failures: 0,
      lastFailure: null,
      cooldownUntil: null,
      disabled: false,
      callsToday: 0,
      quota: p.dailyLimit || 99999,
    };
  });
}
initProviderState();

// ===================== SAFE LOGGER =====================
async function monitor(topicId, pageId, postId, action, message, autoGenerated = false) {
  try {
    if (!pageId) pageId = 'SYSTEM';
    await AiLog.create({ topicId: topicId || null, pageId, postId: postId || null, action, message, autoGenerated });
    console.log(`üßæ LOG ‚Üí ${action} : ${message}`);
  } catch (err) {
    console.error('‚ùå LOG ERROR:', err.message);
  }
}

// ===================== LOG CLEANUP =====================
// Cleans only non-auto-generated logs
async function cleanupLogs() {
  const cutoff = new Date(Date.now() - 30 * 60 * 1000); // 30 minutes
  await AiLog.deleteMany({ createdAt: { $lt: cutoff }, autoGenerated: { $ne: true } });
  console.log('üóë Old non-auto-generated logs cleaned');
}
setInterval(cleanupLogs, 15 * 60 * 1000); // every 15 min

// ===================== CONTENT ANGLES =====================
const ANGLES = ['memory','observation','curiosity','experience','reflection','surprise','casual'];

// ===================== CLEAN TEXT =====================
function cleanText(text = '') {
  return text.replace(/[‚Ä¢#*_`]/g, '').replace(/\s{2,}/g, ' ').trim();
}

// ===================== PROMPT BUILDER =====================
function buildPrompt({ topic, angle, isTrending, isCritical, category }) {
  let base = '';
  if (isCritical) base = `Write a calm, factual post about a very recent event related to ${topic}. No opinions.`;
  else if (isTrending) base = `Write a natural post reacting to something trending about ${topic}.`;
  else {
    const map = {
      memory: `Write a post recalling a memory related to ${topic}.`,
      observation: `Write a post sharing a simple observation about ${topic}.`,
      curiosity: `Write a post expressing curiosity about ${topic}.`,
      experience: `Write a post describing a personal experience related to ${topic}.`,
      reflection: `Write a quiet reflection about ${topic}.`,
      surprise: `Write a post reacting with mild surprise about ${topic}.`,
      casual: `Write a casual post about ${topic}.`
    };
    base = map[angle] || map.casual;
  }

  return `${base}

Rules:
- Write like a real human
- No advice
- No teaching
- No lists
- No emojis
- No hashtags
- No AI tone
- Consider the category: ${category || 'General'}
`;
}

// ===================== PROVIDER SELECTION =====================
function selectProvider(providers) {
  const now = new Date();
  for (const p of providers) {
    const state = providerState[p.name];
    if (state.disabled) continue;
    if (state.cooldownUntil && now < state.cooldownUntil) continue;
    if (state.callsToday >= state.quota) continue;
    return p;
  }
  return null;
}

// ===================== GENERATE TEXT =====================
async function generateText(topic, angle, pageId, options = {}) {
  let lastError = null;
  for (let attempt = 0; attempt < TextProviders.length; attempt++) {
    const provider = selectProvider(TextProviders);
    if (!provider) break;
    const state = providerState[provider.name];

    await monitor(null, pageId, null, 'TEXT_REQUEST', `Attempting text from ${provider.name}`, options.autoGenerated);

    try {
      const text = await provider.generate(buildPrompt({ topic, angle, ...options }));
      state.callsToday++;
      if (!text) throw new Error('Empty response');
      state.failures = 0;
      return cleanText(text);
    } catch (err) {
      lastError = err;
      state.failures++;
      state.lastFailure = new Date();
      state.cooldownUntil = new Date(Date.now() + Math.min(state.failures * 1000 * 60, 10 * 60 * 1000));
      await monitor(null, pageId, null, 'TEXT_FAILED', `${provider.name} failed: ${err.message}`, options.autoGenerated);
    }
  }
  await monitor(null, pageId, null, 'GENERATION_ABORTED', `All text providers failed: ${lastError?.message}`, options.autoGenerated);
  return null;
}

// ===================== GENERATE IMAGE =====================
async function generateImage(topic, pageId, options = {}) {
  let lastError = null;
  for (let attempt = 0; attempt < ImageProviders.length; attempt++) {
    const provider = selectProvider(ImageProviders);
    if (!provider) break;
    const state = providerState[provider.name];

    await monitor(null, pageId, null, 'IMAGE_REQUEST', `Attempting image from ${provider.name}`, options.autoGenerated);

    try {
      const url = await provider.generate(`A realistic everyday photo related to ${topic}. No text.`);
      state.callsToday++;
      if (!url) throw new Error('Empty response');
      state.failures = 0;
      return url;
    } catch (err) {
      lastError = err;
      state.failures++;
      state.lastFailure = new Date();
      state.cooldownUntil = new Date(Date.now() + Math.min(state.failures * 1000 * 60, 10 * 60 * 1000));
      await monitor(null, pageId, null, 'IMAGE_FAILED', `${provider.name} failed: ${err.message}`, options.autoGenerated);
    }
  }
  await monitor(null, pageId, null, 'GENERATION_ABORTED', `All image providers failed: ${lastError?.message}`, options.autoGenerated);
  return null;
}

// ===================== CORE GENERATOR =====================
async function generatePostsForTopic(topicId, options = {}) {
  const topic = await AiTopic.findById(topicId);
  if (!topic) throw new Error('Topic not found');
  const page = await Page.findOne({ pageId: topic.pageId });
  if (!page) throw new Error('Page not found');

  if (!Array.isArray(topic.times) || topic.times.length === 0) throw new Error('Invalid posting times');
  if (!topic.postsPerDay || topic.postsPerDay < 1) throw new Error('postsPerDay must be > 0');

  const { postsPerDay, times, startDate, endDate, repeatType, includeMedia, category } = topic;

  const start = new Date(startDate);
  const end = new Date(endDate);

  let angleIndex = 0, createdPosts = [], safety = 0;

  await monitor(topic._id, topic.pageId, null, 'GENERATION_START', `Started generating posts for "${topic.topicName}"`);

  for (let day = new Date(start); day <= end; ) {
    if (++safety > 500) break;

    for (let i = 0; i < postsPerDay; i++) {
      const angle = ANGLES[angleIndex % ANGLES.length];
      angleIndex++;

      // Avoid duplicate post for same topic & angle
      const existing = await AiScheduledPost.findOne({ topicId: topic._id, 'meta.angle': angle, status: { $in: ['PENDING','SCHEDULED'] } });
      if (existing) continue;

      const text = await generateText(topic.topicName, angle, topic.pageId, { isTrending: false, isCritical: false, category, autoGenerated: false });
      if (!text) continue;

      let mediaUrl = null;
      if (includeMedia && Math.random() > 0.4) {
        mediaUrl = await generateImage(topic.topicName, topic.pageId, { autoGenerated: false });
      }

      let time = times[i % times.length] || '09:00';
      const [h, m] = time.split(':');
      let scheduledTime = moment.tz(day, 'Africa/Nairobi').hour(Number(h)).minute(Number(m)).second(0).millisecond(0);

      // Slight ¬±10 min shuffle to avoid collisions
      scheduledTime = scheduledTime.add(Math.floor(Math.random() * 21 - 10), 'minutes');

      const post = await AiScheduledPost.create({
        topicId: topic._id,
        pageId: topic.pageId,
        text,
        mediaUrl,
        scheduledTime: scheduledTime.toDate(),
        status: 'PENDING',
        retryCount: 0,
        meta: { angle, category }
      });

      createdPosts.push(post);
      await monitor(topic._id, topic.pageId, post._id, 'POST_CREATED', `Post scheduled for ${scheduledTime.format()}`);
      await new Promise(r => setTimeout(r, 200)); // rate limit
    }

    if (repeatType === 'weekly') day.setDate(day.getDate() + 7);
    else if (repeatType === 'monthly') day.setMonth(day.getMonth() + 1);
    else day.setDate(day.getDate() + 1);
  }

  await monitor(topic._id, topic.pageId, null, 'GENERATION_COMPLETE', `Generated ${createdPosts.length} posts.`);
  return createdPosts;
}

// ===================== AUTO GENERATION =====================
async function autoGeneratePosts(maxPostsPerPage = 10) {
  const pages = await Page.find({});
  for (const page of pages) {
    // Count existing scheduled posts
    const currentPosts = await AiScheduledPost.countDocuments({ pageId: page.pageId, status: 'PENDING' });
    const slotsAvailable = maxPostsPerPage - currentPosts;
    if (slotsAvailable <= 0) continue;

    // Fetch topics with remaining posts
    const topics = await AiTopic.find({ pageId: page.pageId, deleted: { $ne: true } }).sort({ createdAt: 1 });
    for (const topic of topics) {
      const scheduledCount = await AiScheduledPost.countDocuments({ topicId: topic._id, status: { $in: ['PENDING','SCHEDULED'] } });
      if (scheduledCount >= 4) {
        // Topic maxed out
        continue;
      }
      const remainingSlots = Math.min(4 - scheduledCount, slotsAvailable);
      for (let i = 0; i < remainingSlots; i++) {
        await generatePostsForTopic(topic._id);
      }
    }
  }
}

// Background auto-generation loop
setInterval(autoGeneratePosts, 30 * 1000); // every 30 seconds (adjust as needed)

// ===================== DELETE POSTS =====================
async function deleteTopicPosts(topicId) {
  const posts = await AiScheduledPost.find({ topicId });
  for (const post of posts) {
    await monitor(topicId, post.pageId, post._id, 'POST_DELETED', 'Post removed', true);
  }
  await AiScheduledPost.deleteMany({ topicId });
}

// ===================== EXPORTS =====================
module.exports = {
  generatePostsForTopic,
  deleteTopicPosts,
  createAiLog: monitor,
  autoGeneratePosts,
};
